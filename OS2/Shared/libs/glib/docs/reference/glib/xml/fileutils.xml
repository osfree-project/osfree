<refentry id="glib-File-Utilities">
<refmeta>
<refentrytitle role="top_of_page">File Utilities</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GLIB Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>File Utilities</refname>
<refpurpose>various file-related functions</refpurpose>
<!--[<xref linkend="desc" endterm="desc.title"/>]-->
</refnamediv>

<refsynopsisdiv role="synopsis">
<title role="synopsis.title">Synopsis</title>

<synopsis>

#include &lt;glib.h&gt;
#include &lt;glib/gstdio.h&gt;


enum                <link linkend="GFileError">GFileError</link>;
#define             <link linkend="G-FILE-ERROR:CAPS">G_FILE_ERROR</link>
enum                <link linkend="GFileTest">GFileTest</link>;
<link linkend="GFileError">GFileError</link>          <link linkend="g-file-error-from-errno">g_file_error_from_errno</link>             (<link linkend="gint">gint</link> err_no);
<link linkend="gboolean">gboolean</link>            <link linkend="g-file-get-contents">g_file_get_contents</link>                 (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="gchar">gchar</link> **contents,
                                                         <link linkend="gsize">gsize</link> *length,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="g-file-set-contents">g_file_set_contents</link>                 (const <link linkend="gchar">gchar</link> *filename,
                                                         const <link linkend="gchar">gchar</link> *contents,
                                                         <link linkend="gssize">gssize</link> length,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gboolean">gboolean</link>            <link linkend="g-file-test">g_file_test</link>                         (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="GFileTest">GFileTest</link> test);
<link linkend="gint">gint</link>                <link linkend="g-mkstemp">g_mkstemp</link>                           (<link linkend="gchar">gchar</link> *tmpl);
<link linkend="gint">gint</link>                <link linkend="g-file-open-tmp">g_file_open_tmp</link>                     (const <link linkend="gchar">gchar</link> *tmpl,
                                                         <link linkend="gchar">gchar</link> **name_used,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="gchar">gchar</link>*              <link linkend="g-file-read-link">g_file_read_link</link>                    (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="int">int</link>                 <link linkend="g-mkdir-with-parents">g_mkdir_with_parents</link>                (const <link linkend="gchar">gchar</link> *pathname,
                                                         <link linkend="int">int</link> mode);

                    <link linkend="GDir">GDir</link>;
<link linkend="GDir">GDir</link>*               <link linkend="g-dir-open">g_dir_open</link>                          (const <link linkend="gchar">gchar</link> *path,
                                                         <link linkend="guint">guint</link> flags,
                                                         <link linkend="GError">GError</link> **error);
const <link linkend="gchar">gchar</link>*        <link linkend="g-dir-read-name">g_dir_read_name</link>                     (<link linkend="GDir">GDir</link> *dir);
<link linkend="void">void</link>                <link linkend="g-dir-rewind">g_dir_rewind</link>                        (<link linkend="GDir">GDir</link> *dir);
<link linkend="void">void</link>                <link linkend="g-dir-close">g_dir_close</link>                         (<link linkend="GDir">GDir</link> *dir);

                    <link linkend="GMappedFile">GMappedFile</link>;
<link linkend="GMappedFile">GMappedFile</link>*        <link linkend="g-mapped-file-new">g_mapped_file_new</link>                   (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="gboolean">gboolean</link> writable,
                                                         <link linkend="GError">GError</link> **error);
<link linkend="void">void</link>                <link linkend="g-mapped-file-free">g_mapped_file_free</link>                  (<link linkend="GMappedFile">GMappedFile</link> *file);
<link linkend="gsize">gsize</link>               <link linkend="g-mapped-file-get-length">g_mapped_file_get_length</link>            (<link linkend="GMappedFile">GMappedFile</link> *file);
<link linkend="gchar">gchar</link>*              <link linkend="g-mapped-file-get-contents">g_mapped_file_get_contents</link>          (<link linkend="GMappedFile">GMappedFile</link> *file);

<link linkend="int">int</link>                 <link linkend="g-open">g_open</link>                              (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> flags,
                                                         <link linkend="int">int</link> mode);
<link linkend="int">int</link>                 <link linkend="g-rename">g_rename</link>                            (const <link linkend="gchar">gchar</link> *oldfilename,
                                                         const <link linkend="gchar">gchar</link> *newfilename);
<link linkend="int">int</link>                 <link linkend="g-mkdir">g_mkdir</link>                             (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> mode);
<link linkend="int">int</link>                 <link linkend="g-stat">g_stat</link>                              (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="struct-stat">struct stat</link> *buf);
<link linkend="int">int</link>                 <link linkend="g-lstat">g_lstat</link>                             (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="struct-stat">struct stat</link> *buf);
<link linkend="int">int</link>                 <link linkend="g-unlink">g_unlink</link>                            (const <link linkend="gchar">gchar</link> *filename);
<link linkend="int">int</link>                 <link linkend="g-remove">g_remove</link>                            (const <link linkend="gchar">gchar</link> *filename);
<link linkend="int">int</link>                 <link linkend="g-rmdir">g_rmdir</link>                             (const <link linkend="gchar">gchar</link> *filename);
<link linkend="FILE:CAPS">FILE</link>*               <link linkend="g-fopen">g_fopen</link>                             (const <link linkend="gchar">gchar</link> *filename,
                                                         const <link linkend="gchar">gchar</link> *mode);
<link linkend="FILE:CAPS">FILE</link>*               <link linkend="g-freopen">g_freopen</link>                           (const <link linkend="gchar">gchar</link> *filename,
                                                         const <link linkend="gchar">gchar</link> *mode,
                                                         <link linkend="FILE:CAPS">FILE</link> *stream);
<link linkend="int">int</link>                 <link linkend="g-chmod">g_chmod</link>                             (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> mode);
<link linkend="int">int</link>                 <link linkend="g-access">g_access</link>                            (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> mode);
<link linkend="int">int</link>                 <link linkend="g-creat">g_creat</link>                             (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> mode);
<link linkend="int">int</link>                 <link linkend="g-chdir">g_chdir</link>                             (const <link linkend="gchar">gchar</link> *path);

</synopsis>
</refsynopsisdiv>









<refsect1 role="desc">
<title role="desc.title">Description</title>
<para>
There is a group of functions which wrap the common POSIX functions 
dealing with filenames (<link linkend="g-open"><function>g_open()</function></link>, <link linkend="g-rename"><function>g_rename()</function></link>, <link linkend="g-mkdir"><function>g_mkdir()</function></link>, <link linkend="g-stat"><function>g_stat()</function></link>, 
<link linkend="g-unlink"><function>g_unlink()</function></link>, <link linkend="g-remove"><function>g_remove()</function></link>, <link linkend="g-fopen"><function>g_fopen()</function></link>, <link linkend="g-freopen"><function>g_freopen()</function></link>). The point of these 
wrappers is to make it possible to handle file names with any Unicode 
characters in them on Windows without having to use ifdefs and the 
wide character API in the application code.
</para>
<para>
The pathname argument should be in the GLib file name encoding. On
POSIX this is the actual on-disk encoding which might correspond to
the locale settings of the process (or the 
<envar>G_FILENAME_ENCODING</envar> environment variable), or not.
</para>
<para>
On Windows the GLib file name encoding is UTF-8. Note that the
Microsoft C library does not use UTF-8, but has separate APIs for
current system code page and wide characters (UTF-16). The GLib
wrappers call the wide character API if present (on modern Windows
systems), otherwise convert to/from the system code page.
</para>

<para>
Another group of functions allows to open and read directories
in the GLib file name encoding. These are <link linkend="g-dir-open"><function>g_dir_open()</function></link>, 
<link linkend="g-dir-read-name"><function>g_dir_read_name()</function></link>, <link linkend="g-dir-rewind"><function>g_dir_rewind()</function></link>, <link linkend="g-dir-close"><function>g_dir_close()</function></link>.
</para>
</refsect1>

<refsect1 role="details">
<title role="details.title">Details</title>
<refsect2>
<title><anchor id="GFileError" role="enum"/>enum GFileError</title>
<indexterm><primary>GFileError</primary></indexterm><programlisting>typedef enum
{
  G_FILE_ERROR_EXIST,
  G_FILE_ERROR_ISDIR,
  G_FILE_ERROR_ACCES,
  G_FILE_ERROR_NAMETOOLONG,
  G_FILE_ERROR_NOENT,
  G_FILE_ERROR_NOTDIR,
  G_FILE_ERROR_NXIO,
  G_FILE_ERROR_NODEV,
  G_FILE_ERROR_ROFS,
  G_FILE_ERROR_TXTBSY,
  G_FILE_ERROR_FAULT,
  G_FILE_ERROR_LOOP,
  G_FILE_ERROR_NOSPC,
  G_FILE_ERROR_NOMEM,
  G_FILE_ERROR_MFILE,
  G_FILE_ERROR_NFILE,
  G_FILE_ERROR_BADF,
  G_FILE_ERROR_INVAL,
  G_FILE_ERROR_PIPE,
  G_FILE_ERROR_AGAIN,
  G_FILE_ERROR_INTR,
  G_FILE_ERROR_IO,
  G_FILE_ERROR_PERM,
  G_FILE_ERROR_NOSYS,
  G_FILE_ERROR_FAILED
} GFileError;
</programlisting>
<para>
Values corresponding to <literal>errno</literal> codes returned from file operations
on UNIX. Unlike <literal>errno</literal> codes, <link linkend="GFileError"><type>GFileError</type></link> values are available on 
all systems, even Windows. The exact meaning of each code depends on what
sort of file operation you were performing; the UNIX documentation
gives more details. The following error code descriptions come 
from the GNU C Library manual, and are under the copyright
of that manual.
</para>

<para>
It's not very portable to make detailed assumptions about exactly
which errors will be returned from a given operation. Some errors
don't occur on some systems, etc., sometimes there are subtle
differences in when a system will report a given error, etc.
</para><variablelist role="enum">
<varlistentry>
<term><anchor id="G-FILE-ERROR-EXIST:CAPS" role="constant"/><literal>G_FILE_ERROR_EXIST</literal></term>
<listitem><simpara>Operation not permitted; only the owner of the
     file (or other resource) or processes with special privileges can
     perform the operation.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-ISDIR:CAPS" role="constant"/><literal>G_FILE_ERROR_ISDIR</literal></term>
<listitem><simpara>File is a directory; you cannot open a directory
     for writing, or create or remove hard links to it.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-ACCES:CAPS" role="constant"/><literal>G_FILE_ERROR_ACCES</literal></term>
<listitem><simpara>Permission denied; the file permissions do not
     allow the attempted operation.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-NAMETOOLONG:CAPS" role="constant"/><literal>G_FILE_ERROR_NAMETOOLONG</literal></term>
<listitem><simpara>Filename too long.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-NOENT:CAPS" role="constant"/><literal>G_FILE_ERROR_NOENT</literal></term>
<listitem><simpara>No such file or directory.  This is a "file
     doesn't exist" error for ordinary files that are referenced in
     contexts where they are expected to already exist.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-NOTDIR:CAPS" role="constant"/><literal>G_FILE_ERROR_NOTDIR</literal></term>
<listitem><simpara>A file that isn't a directory was specified when
     a directory is required.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-NXIO:CAPS" role="constant"/><literal>G_FILE_ERROR_NXIO</literal></term>
<listitem><simpara>No such device or address.  The system tried to
     use the device represented by a file you specified, and it
     couldn't find the device.  This can mean that the device file was
     installed incorrectly, or that the physical device is missing or
     not correctly attached to the computer.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-NODEV:CAPS" role="constant"/><literal>G_FILE_ERROR_NODEV</literal></term>
<listitem><simpara>This file is of a type that doesn't support
     mapping.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-ROFS:CAPS" role="constant"/><literal>G_FILE_ERROR_ROFS</literal></term>
<listitem><simpara>The directory containing the new link can't be
          modified because it's on a read-only file system.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-TXTBSY:CAPS" role="constant"/><literal>G_FILE_ERROR_TXTBSY</literal></term>
<listitem><simpara>Text file busy.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-FAULT:CAPS" role="constant"/><literal>G_FILE_ERROR_FAULT</literal></term>
<listitem><simpara>You passed in a pointer to bad memory.
  (GLib won't reliably return this, don't pass in pointers to bad
  memory.)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-LOOP:CAPS" role="constant"/><literal>G_FILE_ERROR_LOOP</literal></term>
<listitem><simpara>Too many levels of symbolic links were encountered
  in looking up a file name.  This often indicates a cycle of symbolic
  links.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-NOSPC:CAPS" role="constant"/><literal>G_FILE_ERROR_NOSPC</literal></term>
<listitem><simpara>No space left on device; write operation on a
  file failed because the disk is full.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-NOMEM:CAPS" role="constant"/><literal>G_FILE_ERROR_NOMEM</literal></term>
<listitem><simpara>No memory available.  The system cannot allocate
     more virtual memory because its capacity is full.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-MFILE:CAPS" role="constant"/><literal>G_FILE_ERROR_MFILE</literal></term>
<listitem><simpara>The current process has too many files open and
     can't open any more.  Duplicate descriptors do count toward this
     limit.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-NFILE:CAPS" role="constant"/><literal>G_FILE_ERROR_NFILE</literal></term>
<listitem><simpara>There are too many distinct file openings in the
     entire system.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-BADF:CAPS" role="constant"/><literal>G_FILE_ERROR_BADF</literal></term>
<listitem><simpara>Bad file descriptor; for example, I/O on a
     descriptor that has been closed or reading from a descriptor open
     only for writing (or vice versa).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-INVAL:CAPS" role="constant"/><literal>G_FILE_ERROR_INVAL</literal></term>
<listitem><simpara>Invalid argument.  This is used to indicate
     various kinds of problems with passing the wrong argument to a
     library function.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-PIPE:CAPS" role="constant"/><literal>G_FILE_ERROR_PIPE</literal></term>
<listitem><simpara>Broken pipe; there is no process reading from the
     other end of a pipe.  Every library function that returns this
     error code also generates a `SIGPIPE' signal; this signal
     terminates the program if not handled or blocked.  Thus, your
     program will never actually see this code unless it has handled or
     blocked `SIGPIPE'.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-AGAIN:CAPS" role="constant"/><literal>G_FILE_ERROR_AGAIN</literal></term>
<listitem><simpara>Resource temporarily unavailable; the call might
     work if you try again later.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-INTR:CAPS" role="constant"/><literal>G_FILE_ERROR_INTR</literal></term>
<listitem><simpara>Interrupted function call; an asynchronous signal
     occurred and prevented completion of the call.  When this
     happens, you should try the call again.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-IO:CAPS" role="constant"/><literal>G_FILE_ERROR_IO</literal></term>
<listitem><simpara>Input/output error; usually used for physical read
    or write errors. i.e. the disk or other physical device hardware
    is returning errors.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-PERM:CAPS" role="constant"/><literal>G_FILE_ERROR_PERM</literal></term>
<listitem><simpara>Operation not permitted; only the owner of the
     file (or other resource) or processes with special privileges can
     perform the operation.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-NOSYS:CAPS" role="constant"/><literal>G_FILE_ERROR_NOSYS</literal></term>
<listitem><simpara>Function not implemented; this indicates that the
    system is missing some functionality.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-ERROR-FAILED:CAPS" role="constant"/><literal>G_FILE_ERROR_FAILED</literal></term>
<listitem><simpara>Does not correspond to a UNIX error code; this
  is the standard "failed for unspecified reason" error code present in 
  all <link linkend="GError"><type>GError</type></link> error code enumerations. Returned if no specific
  code applies.

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="G-FILE-ERROR:CAPS" role="macro"/>G_FILE_ERROR</title>
<indexterm><primary>G_FILE_ERROR</primary></indexterm><programlisting>#define G_FILE_ERROR g_file_error_quark ()
</programlisting>
<para>
Error domain for file operations. Errors in this domain will
be from the <link linkend="GFileError"><type>GFileError</type></link> enumeration. See <link linkend="GError"><type>GError</type></link> for information on 
error domains.
</para></refsect2>
<refsect2>
<title><anchor id="GFileTest" role="enum"/>enum GFileTest</title>
<indexterm><primary>GFileTest</primary></indexterm><programlisting>typedef enum
{
  G_FILE_TEST_IS_REGULAR    = 1 &lt;&lt; 0,
  G_FILE_TEST_IS_SYMLINK    = 1 &lt;&lt; 1,
  G_FILE_TEST_IS_DIR        = 1 &lt;&lt; 2,
  G_FILE_TEST_IS_EXECUTABLE = 1 &lt;&lt; 3,
  G_FILE_TEST_EXISTS        = 1 &lt;&lt; 4
} GFileTest;
</programlisting>
<para>
A test to perform on a file using <link linkend="g-file-test"><function>g_file_test()</function></link>.
</para><variablelist role="enum">
<varlistentry>
<term><anchor id="G-FILE-TEST-IS-REGULAR:CAPS" role="constant"/><literal>G_FILE_TEST_IS_REGULAR</literal></term>
<listitem><simpara><link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the file is a regular file (not a directory).
    Note that this test will also return <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the tested file is a symlink
    to a regular file.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-TEST-IS-SYMLINK:CAPS" role="constant"/><literal>G_FILE_TEST_IS_SYMLINK</literal></term>
<listitem><simpara><link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the file is a symlink.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-TEST-IS-DIR:CAPS" role="constant"/><literal>G_FILE_TEST_IS_DIR</literal></term>
<listitem><simpara><link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the file is a directory.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-TEST-IS-EXECUTABLE:CAPS" role="constant"/><literal>G_FILE_TEST_IS_EXECUTABLE</literal></term>
<listitem><simpara><link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the file is executable.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><anchor id="G-FILE-TEST-EXISTS:CAPS" role="constant"/><literal>G_FILE_TEST_EXISTS</literal></term>
<listitem><simpara><link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the file exists. 
    It may or may not be a regular file.

</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-file-error-from-errno" role="function"/>g_file_error_from_errno ()</title>
<indexterm><primary>g_file_error_from_errno</primary></indexterm><programlisting><link linkend="GFileError">GFileError</link>          g_file_error_from_errno             (<link linkend="gint">gint</link> err_no);</programlisting>
<para>
Gets a <link linkend="GFileError"><type>GFileError</type></link> constant based on the passed-in <parameter>errno</parameter>.
For example, if you pass in <link linkend="EEXIST:CAPS"><literal>EEXIST</literal></link> this function returns
<link linkend="G-FILE-ERROR-EXIST:CAPS"><type>G_FILE_ERROR_EXIST</type></link>. Unlike <parameter>errno</parameter> values, you can portably
assume that all <link linkend="GFileError"><type>GFileError</type></link> values will exist.
</para>
<para>
Normally a <link linkend="GFileError"><type>GFileError</type></link> value goes into a <link linkend="GError"><type>GError</type></link> returned
from a function that manipulates files. So you would use
<link linkend="g-file-error-from-errno"><function>g_file_error_from_errno()</function></link> when constructing a <link linkend="GError"><type>GError</type></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>err_no</parameter>&nbsp;:</term>
<listitem><simpara> an "errno" value
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="GFileError"><type>GFileError</type></link> corresponding to the given <parameter>errno</parameter>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-file-get-contents" role="function"/>g_file_get_contents ()</title>
<indexterm><primary>g_file_get_contents</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            g_file_get_contents                 (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="gchar">gchar</link> **contents,
                                                         <link linkend="gsize">gsize</link> *length,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Reads an entire file into allocated memory, with good error
checking. 
</para>
<para>
If the call was successful, it returns <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> and sets <parameter>contents</parameter> to the file 
contents and <parameter>length</parameter> to the length of the file contents in bytes. The string 
stored in <parameter>contents</parameter> will be nul-terminated, so for text files you can pass 
<link linkend="NULL:CAPS"><literal>NULL</literal></link> for the <parameter>length</parameter> argument. If the call was not successful, it returns 
<link linkend="FALSE:CAPS"><literal>FALSE</literal></link> and sets <parameter>error</parameter>. The error domain is <link linkend="G-FILE-ERROR:CAPS"><type>G_FILE_ERROR</type></link>. Possible error  
codes are those in the <link linkend="GFileError"><type>GFileError</type></link> enumeration. In the error case, 
<parameter>contents</parameter> is set to <link linkend="NULL:CAPS"><literal>NULL</literal></link> and <parameter>length</parameter> is set to zero.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> name of a file to read contents from, in the GLib file name encoding
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>contents</parameter>&nbsp;:</term>
<listitem><simpara> location to store an allocated string
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>length</parameter>&nbsp;:</term>
<listitem><simpara> location to store length in bytes of the contents, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> return location for a <link linkend="GError"><type>GError</type></link>, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success, <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> if an error occurred
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-file-set-contents" role="function" condition="since:2.8"/>g_file_set_contents ()</title>
<indexterm role="2.8"><primary>g_file_set_contents</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            g_file_set_contents                 (const <link linkend="gchar">gchar</link> *filename,
                                                         const <link linkend="gchar">gchar</link> *contents,
                                                         <link linkend="gssize">gssize</link> length,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Writes all of <parameter>contents</parameter> to a file named <parameter>filename</parameter>, with good error checking.
If a file called <parameter>filename</parameter> already exists it will be overwritten.
</para>
<para>
This write is atomic in the sense that it is first written to a temporary
file which is then renamed to the final name. Notes:
<itemizedlist>
<listitem>
   On Unix, if <parameter>filename</parameter> already exists hard links to <parameter>filename</parameter> will break.
   Also since the file is recreated, existing permissions, access control
   lists, metadata etc. may be lost. If <parameter>filename</parameter> is a symbolic link,
   the link itself will be replaced, not the linked file.
</listitem>
<listitem>
  On Windows renaming a file will not remove an existing file with the
  new name, so on Windows there is a race condition between the existing
  file being removed and the temporary file being renamed.
</listitem>
<listitem>
  On Windows there is no way to remove a file that is open to some
  process, or mapped into memory. Thus, this function will fail if
  <parameter>filename</parameter> already exists and is open.
</listitem>
</itemizedlist>
</para>
<para>
If the call was sucessful, it returns <link linkend="TRUE:CAPS"><literal>TRUE</literal></link>. If the call was not successful,
it returns <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> and sets <parameter>error</parameter>. The error domain is <link linkend="G-FILE-ERROR:CAPS"><type>G_FILE_ERROR</type></link>.
Possible error codes are those in the <link linkend="GFileError"><type>GFileError</type></link> enumeration.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> name of a file to write <parameter>contents</parameter> to, in the GLib file name
  encoding
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>contents</parameter>&nbsp;:</term>
<listitem><simpara> string to write to the file
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>length</parameter>&nbsp;:</term>
<listitem><simpara> length of <parameter>contents</parameter>, or -1 if <parameter>contents</parameter> is a nul-terminated string
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> return location for a <link linkend="GError"><type>GError</type></link>, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> on success, <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> if an error occurred

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>
<refsect2>
<title><anchor id="g-file-test" role="function"/>g_file_test ()</title>
<indexterm><primary>g_file_test</primary></indexterm><programlisting><link linkend="gboolean">gboolean</link>            g_file_test                         (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="GFileTest">GFileTest</link> test);</programlisting>
<para>
Returns <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if any of the tests in the bitfield <parameter>test</parameter> are
<link linkend="TRUE:CAPS"><literal>TRUE</literal></link>. For example, <literal>(G_FILE_TEST_EXISTS | 
G_FILE_TEST_IS_DIR)</literal> will return <link linkend="TRUE:CAPS"><literal>TRUE</literal></link> if the file exists; 
the check whether it's a directory doesn't matter since the existence 
test is <link linkend="TRUE:CAPS"><literal>TRUE</literal></link>. With the current set of available tests, there's no point
passing in more than one test at a time.
</para>
<para>
Apart from <link linkend="G-FILE-TEST-IS-SYMLINK:CAPS"><literal>G_FILE_TEST_IS_SYMLINK</literal></link> all tests follow symbolic links,
so for a symbolic link to a regular file <link linkend="g-file-test"><function>g_file_test()</function></link> will return
<link linkend="TRUE:CAPS"><literal>TRUE</literal></link> for both <link linkend="G-FILE-TEST-IS-SYMLINK:CAPS"><literal>G_FILE_TEST_IS_SYMLINK</literal></link> and <link linkend="G-FILE-TEST-IS-REGULAR:CAPS"><literal>G_FILE_TEST_IS_REGULAR</literal></link>.
</para>
<para>
Note, that for a dangling symbolic link <link linkend="g-file-test"><function>g_file_test()</function></link> will return
<link linkend="TRUE:CAPS"><literal>TRUE</literal></link> for <link linkend="G-FILE-TEST-IS-SYMLINK:CAPS"><literal>G_FILE_TEST_IS_SYMLINK</literal></link> and <link linkend="FALSE:CAPS"><literal>FALSE</literal></link> for all other flags.
</para>
<para>
You should never use <link linkend="g-file-test"><function>g_file_test()</function></link> to test whether it is safe
to perform an operation, because there is always the possibility
of the condition changing before you actually perform the operation.
For example, you might think you could use <link linkend="G-FILE-TEST-IS-SYMLINK:CAPS"><literal>G_FILE_TEST_IS_SYMLINK</literal></link>
to know whether it is safe to write to a file without being
tricked into writing into a different location. It doesn't work!
<informalexample><programlisting>
/&ast; DON'T DO THIS &ast;/
 if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK)) 
   {
     fd = g_open (filename, O_WRONLY);
     /&ast; write to fd &ast;/
   }
</programlisting></informalexample>
</para>
<para>
Another thing to note is that <link linkend="G-FILE-TEST-EXISTS:CAPS"><literal>G_FILE_TEST_EXISTS</literal></link> and
<link linkend="G-FILE-TEST-IS-EXECUTABLE:CAPS"><literal>G_FILE_TEST_IS_EXECUTABLE</literal></link> are implemented using the <link linkend="access"><function>access()</function></link>
system call. This usually doesn't matter, but if your program
is setuid or setgid it means that these tests will give you
the answer for the real user ID and group ID, rather than the
effective user ID and group ID.
</para>
<para>
On Windows, there are no symlinks, so testing for
<link linkend="G-FILE-TEST-IS-SYMLINK:CAPS"><literal>G_FILE_TEST_IS_SYMLINK</literal></link> will always return <link linkend="FALSE:CAPS"><literal>FALSE</literal></link>. Testing for
<link linkend="G-FILE-TEST-IS-EXECUTABLE:CAPS"><literal>G_FILE_TEST_IS_EXECUTABLE</literal></link> will just check that the file exists and
its name indicates that it is executable, checking for well-known
extensions and those listed in the <link linkend="PATHEXT:CAPS"><literal>PATHEXT</literal></link> environment variable.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a filename to test in the GLib file name encoding
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>test</parameter>&nbsp;:</term>
<listitem><simpara> bitfield of <link linkend="GFileTest"><type>GFileTest</type></link> flags
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> whether a test was <link linkend="TRUE:CAPS"><literal>TRUE</literal></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-mkstemp" role="function"/>g_mkstemp ()</title>
<indexterm><primary>g_mkstemp</primary></indexterm><programlisting><link linkend="gint">gint</link>                g_mkstemp                           (<link linkend="gchar">gchar</link> *tmpl);</programlisting>
<para>
Opens a temporary file. See the <link linkend="mkstemp"><function>mkstemp()</function></link> documentation
on most UNIX-like systems. 
</para>
<para>
The parameter is a string that should follow the rules for
<link linkend="mkstemp"><function>mkstemp()</function></link> templates, i.e. contain the string "XXXXXX". 
<link linkend="g-mkstemp"><function>g_mkstemp()</function></link> is slightly more flexible than <link linkend="mkstemp"><function>mkstemp()</function></link>
in that the sequence does not have to occur at the very end of the 
template. The X string will 
be modified to form the name of a file that didn't exist.
The string should be in the GLib file name encoding. Most importantly, 
on Windows it should be in UTF-8.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>tmpl</parameter>&nbsp;:</term>
<listitem><simpara> template filename
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> A file handle (as from <link linkend="open"><function>open()</function></link>) to the file
opened for reading and writing. The file is opened in binary mode
on platforms where there is a difference. The file handle should be
closed with <link linkend="close"><function>close()</function></link>. In case of errors, -1 is returned.  
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-file-open-tmp" role="function"/>g_file_open_tmp ()</title>
<indexterm><primary>g_file_open_tmp</primary></indexterm><programlisting><link linkend="gint">gint</link>                g_file_open_tmp                     (const <link linkend="gchar">gchar</link> *tmpl,
                                                         <link linkend="gchar">gchar</link> **name_used,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Opens a file for writing in the preferred directory for temporary
files (as returned by <link linkend="g-get-tmp-dir"><function>g_get_tmp_dir()</function></link>). 
</para>
<para>
<parameter>tmpl</parameter> should be a string in the GLib file name encoding containing 
a sequence of six 'X' characters, as the parameter to <link linkend="g-mkstemp"><function>g_mkstemp()</function></link>.
However, unlike these functions, the template should only be a
basename, no directory components are allowed. If template is
<link linkend="NULL:CAPS"><literal>NULL</literal></link>, a default template is used.
</para>
<para>
Note that in contrast to <link linkend="g-mkstemp"><function>g_mkstemp()</function></link> (and <link linkend="mkstemp"><function>mkstemp()</function></link>) 
<parameter>tmpl</parameter> is not modified, and might thus be a read-only literal string.
</para>
<para>
The actual name used is returned in <parameter>name_used</parameter> if non-<link linkend="NULL:CAPS"><literal>NULL</literal></link>. This
string should be freed with <link linkend="g-free"><function>g_free()</function></link> when not needed any longer.
The returned name is in the GLib file name encoding.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>tmpl</parameter>&nbsp;:</term>
<listitem><simpara> Template for file name, as in <link linkend="g-mkstemp"><function>g_mkstemp()</function></link>, basename only,
       or <link linkend="NULL:CAPS"><literal>NULL</literal></link>, to a default template
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>name_used</parameter>&nbsp;:</term>
<listitem><simpara> location to store actual name used
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> return location for a <link linkend="GError"><type>GError</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> A file handle (as from <link linkend="open"><function>open()</function></link>) to 
the file opened for reading and writing. The file is opened in binary 
mode on platforms where there is a difference. The file handle should be
closed with <link linkend="close"><function>close()</function></link>. In case of errors, -1 is returned 
and <parameter>error</parameter> will be set.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-file-read-link" role="function" condition="since:2.4"/>g_file_read_link ()</title>
<indexterm role="2.4"><primary>g_file_read_link</primary></indexterm><programlisting><link linkend="gchar">gchar</link>*              g_file_read_link                    (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Reads the contents of the symbolic link <parameter>filename</parameter> like the POSIX
<link linkend="readlink"><function>readlink()</function></link> function.  The returned string is in the encoding used
for filenames. Use <link linkend="g-filename-to-utf8"><function>g_filename_to_utf8()</function></link> to convert it to UTF-8.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> the symbolic link
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> return location for a <link linkend="GError"><type>GError</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> A newly allocated string with the contents of the symbolic link, 
         or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if an error occurred.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.4
</para></refsect2>
<refsect2>
<title><anchor id="g-mkdir-with-parents" role="function" condition="since:2.8"/>g_mkdir_with_parents ()</title>
<indexterm role="2.8"><primary>g_mkdir_with_parents</primary></indexterm><programlisting><link linkend="int">int</link>                 g_mkdir_with_parents                (const <link linkend="gchar">gchar</link> *pathname,
                                                         <link linkend="int">int</link> mode);</programlisting>
<para>
Create a directory if it doesn't already exist. Create intermediate
parent directories as needed, too.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>pathname</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter>&nbsp;:</term>
<listitem><simpara> permissions to use for newly created directories
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> 0 if the directory already exists, or was successfully
created. Returns -1 if an error occurred, with errno set.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>
<refsect2>
<title><anchor id="GDir" role="struct"/>GDir</title>
<indexterm><primary>GDir</primary></indexterm><programlisting>typedef struct _GDir GDir;</programlisting>
<para>
An opaque structure representing an opened directory.
</para></refsect2>
<refsect2>
<title><anchor id="g-dir-open" role="function"/>g_dir_open ()</title>
<indexterm><primary>g_dir_open</primary></indexterm><programlisting><link linkend="GDir">GDir</link>*               g_dir_open                          (const <link linkend="gchar">gchar</link> *path,
                                                         <link linkend="guint">guint</link> flags,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Opens a directory for reading. The names of the files in the
directory can then be retrieved using <link linkend="g-dir-read-name"><function>g_dir_read_name()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>path</parameter>&nbsp;:</term>
<listitem><simpara> the path to the directory you are interested in. On Unix
        in the on-disk encoding. On Windows in UTF-8
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>flags</parameter>&nbsp;:</term>
<listitem><simpara> Currently must be set to 0. Reserved for future use.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> return location for a <link linkend="GError"><type>GError</type></link>, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>.
        If non-<link linkend="NULL:CAPS"><literal>NULL</literal></link>, an error will be set if and only if
        <link linkend="g-dir-open"><function>g_dir_open()</function></link> fails.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a newly allocated <link linkend="GDir"><type>GDir</type></link> on success, <link linkend="NULL:CAPS"><literal>NULL</literal></link> on failure.
  If non-<link linkend="NULL:CAPS"><literal>NULL</literal></link>, you must free the result with <link linkend="g-dir-close"><function>g_dir_close()</function></link>
  when you are finished with it.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-dir-read-name" role="function"/>g_dir_read_name ()</title>
<indexterm><primary>g_dir_read_name</primary></indexterm><programlisting>const <link linkend="gchar">gchar</link>*        g_dir_read_name                     (<link linkend="GDir">GDir</link> *dir);</programlisting>
<para>
Retrieves the name of the next entry in the directory.  The '.' and
'..' entries are omitted. On Windows, the returned name is in
UTF-8. On Unix, it is in the on-disk encoding.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>dir</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GDir"><type>GDir</type></link>* created by <link linkend="g-dir-open"><function>g_dir_open()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> The entry's name or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if there are no 
  more entries. The return value is owned by GLib and
  must not be modified or freed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-dir-rewind" role="function"/>g_dir_rewind ()</title>
<indexterm><primary>g_dir_rewind</primary></indexterm><programlisting><link linkend="void">void</link>                g_dir_rewind                        (<link linkend="GDir">GDir</link> *dir);</programlisting>
<para>
Resets the given directory. The next call to <link linkend="g-dir-read-name"><function>g_dir_read_name()</function></link>
will return the first entry again.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>dir</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GDir"><type>GDir</type></link>* created by <link linkend="g-dir-open"><function>g_dir_open()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="g-dir-close" role="function"/>g_dir_close ()</title>
<indexterm><primary>g_dir_close</primary></indexterm><programlisting><link linkend="void">void</link>                g_dir_close                         (<link linkend="GDir">GDir</link> *dir);</programlisting>
<para>
Closes the directory and deallocates all related resources.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>dir</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GDir"><type>GDir</type></link>* created by <link linkend="g-dir-open"><function>g_dir_open()</function></link>
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="GMappedFile" role="struct"/>GMappedFile</title>
<indexterm><primary>GMappedFile</primary></indexterm><programlisting>typedef struct _GMappedFile GMappedFile;</programlisting>
<para>
The <link linkend="GMappedFile"><type>GMappedFile</type></link> represents a file mapping created with
<link linkend="g-mapped-file-new"><function>g_mapped_file_new()</function></link>. It has only private members and should
not be accessed directly.
</para></refsect2>
<refsect2>
<title><anchor id="g-mapped-file-new" role="function" condition="since:2.8"/>g_mapped_file_new ()</title>
<indexterm role="2.8"><primary>g_mapped_file_new</primary></indexterm><programlisting><link linkend="GMappedFile">GMappedFile</link>*        g_mapped_file_new                   (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="gboolean">gboolean</link> writable,
                                                         <link linkend="GError">GError</link> **error);</programlisting>
<para>
Maps a file into memory. On UNIX, this is using the <link linkend="mmap"><function>mmap()</function></link> function.
</para>
<para>
If <parameter>writable</parameter> is <link linkend="TRUE:CAPS"><literal>TRUE</literal></link>, the mapped buffer may be modified, otherwise
it is an error to modify the mapped buffer. Modifications to the buffer 
are not visible to other processes mapping the same file, and are not 
written back to the file.
</para>
<para>
Note that modifications of the underlying file might affect the contents
of the <link linkend="GMappedFile"><type>GMappedFile</type></link>. Therefore, mapping should only be used if the file 
will not be modified, or if all modifications of the file are done
atomically (e.g. using <link linkend="g-file-set-contents"><function>g_file_set_contents()</function></link>).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> The path of the file to load, in the GLib filename encoding
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>writable</parameter>&nbsp;:</term>
<listitem><simpara> whether the mapping should be writable
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>error</parameter>&nbsp;:</term>
<listitem><simpara> return location for a <link linkend="GError"><type>GError</type></link>, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a newly allocated <link linkend="GMappedFile"><type>GMappedFile</type></link> which must be freed
   with <link linkend="g-mapped-file-free"><function>g_mapped_file_free()</function></link>, or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if the mapping failed. 

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>
<refsect2>
<title><anchor id="g-mapped-file-free" role="function" condition="since:2.8"/>g_mapped_file_free ()</title>
<indexterm role="2.8"><primary>g_mapped_file_free</primary></indexterm><programlisting><link linkend="void">void</link>                g_mapped_file_free                  (<link linkend="GMappedFile">GMappedFile</link> *file);</programlisting>
<para>
Unmaps the buffer of <parameter>file</parameter> and frees it.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>file</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GMappedFile"><type>GMappedFile</type></link>
</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>
<refsect2>
<title><anchor id="g-mapped-file-get-length" role="function" condition="since:2.8"/>g_mapped_file_get_length ()</title>
<indexterm role="2.8"><primary>g_mapped_file_get_length</primary></indexterm><programlisting><link linkend="gsize">gsize</link>               g_mapped_file_get_length            (<link linkend="GMappedFile">GMappedFile</link> *file);</programlisting>
<para>
Returns the length of the contents of a <link linkend="GMappedFile"><type>GMappedFile</type></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>file</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GMappedFile"><type>GMappedFile</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the length of the contents of <parameter>file</parameter>.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>
<refsect2>
<title><anchor id="g-mapped-file-get-contents" role="function" condition="since:2.8"/>g_mapped_file_get_contents ()</title>
<indexterm role="2.8"><primary>g_mapped_file_get_contents</primary></indexterm><programlisting><link linkend="gchar">gchar</link>*              g_mapped_file_get_contents          (<link linkend="GMappedFile">GMappedFile</link> *file);</programlisting>
<para>
Returns the contents of a <link linkend="GMappedFile"><type>GMappedFile</type></link>. 
</para>
<para>
Note that the contents may not be zero-terminated,
even if the <link linkend="GMappedFile"><type>GMappedFile</type></link> is backed by a text file.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>file</parameter>&nbsp;:</term>
<listitem><simpara> a <link linkend="GMappedFile"><type>GMappedFile</type></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> the contents of <parameter>file</parameter>.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>
<refsect2>
<title><anchor id="g-open" role="function" condition="since:2.6"/>g_open ()</title>
<indexterm role="2.6"><primary>g_open</primary></indexterm><programlisting><link linkend="int">int</link>                 g_open                              (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> flags,
                                                         <link linkend="int">int</link> mode);</programlisting>
<para>
A wrapper for the POSIX <link linkend="open"><function>open()</function></link> function. The <link linkend="open"><function>open()</function></link> function is
used to convert a pathname into a file descriptor. Note that on
POSIX systems file descriptors are implemented by the operating
system. On Windows, it's the C library that implements <link linkend="open"><function>open()</function></link> and
file descriptors. The actual Windows API for opening files is
something different.
</para>
<para>
See the C library manual for more details about <link linkend="open"><function>open()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>flags</parameter>&nbsp;:</term>
<listitem><simpara> as in <link linkend="open"><function>open()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter>&nbsp;:</term>
<listitem><simpara> as in <link linkend="open"><function>open()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a new file descriptor, or -1 if an error occurred. The
return value can be used exactly like the return value from <link linkend="open"><function>open()</function></link>.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-rename" role="function" condition="since:2.6"/>g_rename ()</title>
<indexterm role="2.6"><primary>g_rename</primary></indexterm><programlisting><link linkend="int">int</link>                 g_rename                            (const <link linkend="gchar">gchar</link> *oldfilename,
                                                         const <link linkend="gchar">gchar</link> *newfilename);</programlisting>
<para>
A wrapper for the POSIX <link linkend="rename"><function>rename()</function></link> function. The <link linkend="rename"><function>rename()</function></link> function 
renames a file, moving it between directories if required.
</para>
<para>
See your C library manual for more details about how <link linkend="rename"><function>rename()</function></link> works
on your system. Note in particular that on Win9x it is not possible
to rename a file if a file with the new name already exists. Also
it is not possible in general on Windows to rename an open file.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>oldfilename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>newfilename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> 0 if the renaming succeeded, -1 if an error occurred

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-mkdir" role="function" condition="since:2.6"/>g_mkdir ()</title>
<indexterm role="2.6"><primary>g_mkdir</primary></indexterm><programlisting><link linkend="int">int</link>                 g_mkdir                             (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> mode);</programlisting>
<para>
A wrapper for the POSIX <link linkend="mkdir"><function>mkdir()</function></link> function. The <link linkend="mkdir"><function>mkdir()</function></link> function 
attempts to create a directory with the given name and permissions.
The mode argument is ignored on Windows.
</para>
<para>
See the C library manual for more details about <link linkend="mkdir"><function>mkdir()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter>&nbsp;:</term>
<listitem><simpara> permissions to use for the newly created directory
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> 0 if the directory was successfully created, -1 if an error 
   occurred

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-stat" role="function" condition="since:2.6"/>g_stat ()</title>
<indexterm role="2.6"><primary>g_stat</primary></indexterm><programlisting><link linkend="int">int</link>                 g_stat                              (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="struct-stat">struct stat</link> *buf);</programlisting>
<para>
A wrapper for the POSIX <link linkend="stat"><function>stat()</function></link> function. The <link linkend="stat"><function>stat()</function></link> function
returns information about a file. On Windows the <link linkend="stat"><function>stat()</function></link> function in
the C library checks only the READONLY attribute and does not look
at the ACL at all. Thus the protection bits in the st_mode field
are a fabrication of little use.
</para>
<para>
See the C library manual for more details about <link linkend="stat"><function>stat()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>buf</parameter>&nbsp;:</term>
<listitem><simpara> a pointer to a <structname>stat</structname> struct, which
   will be filled with the file information
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> 0 if the information was successfully retrieved, -1 if an error 
   occurred

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-lstat" role="function" condition="since:2.6"/>g_lstat ()</title>
<indexterm role="2.6"><primary>g_lstat</primary></indexterm><programlisting><link linkend="int">int</link>                 g_lstat                             (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="struct-stat">struct stat</link> *buf);</programlisting>
<para>
A wrapper for the POSIX <link linkend="lstat"><function>lstat()</function></link> function. The <link linkend="lstat"><function>lstat()</function></link> function is
like <link linkend="stat"><function>stat()</function></link> except that in the case of symbolic links, it returns
information about the symbolic link itself and not the file that it
refers to. If the system does not support symbolic links <link linkend="g-lstat"><function>g_lstat()</function></link>
is identical to <link linkend="g-stat"><function>g_stat()</function></link>.
</para>
<para>
See the C library manual for more details about <link linkend="lstat"><function>lstat()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>buf</parameter>&nbsp;:</term>
<listitem><simpara> a pointer to a <structname>stat</structname> struct, which
   will be filled with the file information
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> 0 if the information was successfully retrieved, -1 if an error 
   occurred

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-unlink" role="function" condition="since:2.6"/>g_unlink ()</title>
<indexterm role="2.6"><primary>g_unlink</primary></indexterm><programlisting><link linkend="int">int</link>                 g_unlink                            (const <link linkend="gchar">gchar</link> *filename);</programlisting>
<para>
A wrapper for the POSIX <link linkend="unlink"><function>unlink()</function></link> function. The <link linkend="unlink"><function>unlink()</function></link> function 
deletes a name from the filesystem. If this was the last link to the 
file and no processes have it opened, the diskspace occupied by the
file is freed.
</para>
<para>
See your C library manual for more details about <link linkend="unlink"><function>unlink()</function></link>. Note
that on Windows, it is in general not possible to delete files that
are open to some process, or mapped into memory.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> 0 if the name was successfully deleted, -1 if an error 
   occurred

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-remove" role="function" condition="since:2.6"/>g_remove ()</title>
<indexterm role="2.6"><primary>g_remove</primary></indexterm><programlisting><link linkend="int">int</link>                 g_remove                            (const <link linkend="gchar">gchar</link> *filename);</programlisting>
<para>
A wrapper for the POSIX <link linkend="remove"><function>remove()</function></link> function. The <link linkend="remove"><function>remove()</function></link> function
deletes a name from the filesystem.
</para>
<para>
See your C library manual for more details about how <link linkend="remove"><function>remove()</function></link> works
on your system. On Unix, <link linkend="remove"><function>remove()</function></link> removes also directories, as it
calls <link linkend="unlink"><function>unlink()</function></link> for files and <link linkend="rmdir"><function>rmdir()</function></link> for directories. On Windows,
although <link linkend="remove"><function>remove()</function></link> in the C library only works for files, this
function tries first <link linkend="remove"><function>remove()</function></link> and then if that fails <link linkend="rmdir"><function>rmdir()</function></link>, and
thus works for both files and directories. Note however, that on
Windows, it is in general not possible to remove a file that is
open to some process, or mapped into memory.
</para>
<para>
If this function fails on Windows you can't infer too much from the
errno value. <link linkend="rmdir"><function>rmdir()</function></link> is tried regardless of what caused <link linkend="remove"><function>remove()</function></link> to
fail. Any errno value set by <link linkend="remove"><function>remove()</function></link> will be overwritten by that
set by <link linkend="rmdir"><function>rmdir()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> 0 if the file was successfully removed, -1 if an error 
   occurred

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-rmdir" role="function" condition="since:2.6"/>g_rmdir ()</title>
<indexterm role="2.6"><primary>g_rmdir</primary></indexterm><programlisting><link linkend="int">int</link>                 g_rmdir                             (const <link linkend="gchar">gchar</link> *filename);</programlisting>
<para>
A wrapper for the POSIX <link linkend="rmdir"><function>rmdir()</function></link> function. The <link linkend="rmdir"><function>rmdir()</function></link> function
deletes a directory from the filesystem.
</para>
<para>
See your C library manual for more details about how <link linkend="rmdir"><function>rmdir()</function></link> works
on your system.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> 0 if the directory was successfully removed, -1 if an error 
   occurred

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-fopen" role="function" condition="since:2.6"/>g_fopen ()</title>
<indexterm role="2.6"><primary>g_fopen</primary></indexterm><programlisting><link linkend="FILE:CAPS">FILE</link>*               g_fopen                             (const <link linkend="gchar">gchar</link> *filename,
                                                         const <link linkend="gchar">gchar</link> *mode);</programlisting>
<para>
A wrapper for the POSIX <link linkend="fopen"><function>fopen()</function></link> function. The <link linkend="fopen"><function>fopen()</function></link> function opens
a file and associates a new stream with it. 
</para>
<para>
See the C library manual for more details about <link linkend="fopen"><function>fopen()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter>&nbsp;:</term>
<listitem><simpara> a string describing the mode in which the file should be 
  opened
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> A <type>FILE</type> pointer if the file was successfully
   opened, or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if an error occurred

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-freopen" role="function" condition="since:2.6"/>g_freopen ()</title>
<indexterm role="2.6"><primary>g_freopen</primary></indexterm><programlisting><link linkend="FILE:CAPS">FILE</link>*               g_freopen                           (const <link linkend="gchar">gchar</link> *filename,
                                                         const <link linkend="gchar">gchar</link> *mode,
                                                         <link linkend="FILE:CAPS">FILE</link> *stream);</programlisting>
<para>
A wrapper for the POSIX <link linkend="freopen"><function>freopen()</function></link> function. The <link linkend="freopen"><function>freopen()</function></link> function
opens a file and associates it with an existing stream.
</para>
<para>
See the C library manual for more details about <link linkend="freopen"><function>freopen()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter>&nbsp;:</term>
<listitem><simpara> a string describing the mode in which the file should be 
  opened
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>stream</parameter>&nbsp;:</term>
<listitem><simpara> an existing stream which will be reused, or <link linkend="NULL:CAPS"><literal>NULL</literal></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> A <type>FILE</type> pointer if the file was successfully
   opened, or <link linkend="NULL:CAPS"><literal>NULL</literal></link> if an error occurred.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.6
</para></refsect2>
<refsect2>
<title><anchor id="g-chmod" role="function" condition="since:2.8"/>g_chmod ()</title>
<indexterm role="2.8"><primary>g_chmod</primary></indexterm><programlisting><link linkend="int">int</link>                 g_chmod                             (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> mode);</programlisting>
<para>
A wrapper for the POSIX <link linkend="chmod"><function>chmod()</function></link> function. The <link linkend="chmod"><function>chmod()</function></link> function is
used to set the permissions of a file system object. Note that on
Windows the file protection mechanism is not at all POSIX-like, and
the underlying <link linkend="chmod"><function>chmod()</function></link> function in the C library just sets or
clears the READONLY attribute. It does not touch any ACL. Software
that needs to manage file permissions on Windows exactly should
use the Win32 API.
</para>
<para>
See the C library manual for more details about <link linkend="chmod"><function>chmod()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter>&nbsp;:</term>
<listitem><simpara> as in <link linkend="chmod"><function>chmod()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> zero if the operation succeeded, -1 on error.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>
<refsect2>
<title><anchor id="g-access" role="function" condition="since:2.8"/>g_access ()</title>
<indexterm role="2.8"><primary>g_access</primary></indexterm><programlisting><link linkend="int">int</link>                 g_access                            (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> mode);</programlisting>
<para>
A wrapper for the POSIX <link linkend="access"><function>access()</function></link> function. This function is used to
test a pathname for one or several of read, write or execute
permissions, or just existence. On Windows, the underlying <link linkend="access"><function>access()</function></link>
function in the C library only checks the READONLY attribute, and
does not look at the ACL at all. Software that needs to handle file
permissions on Windows more exactly should use the Win32 API.
</para>
<para>
See the C library manual for more details about <link linkend="access"><function>access()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter>&nbsp;:</term>
<listitem><simpara> as in <link linkend="access"><function>access()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> zero if the pathname refers to an existing file system
object that has all the tested permissions, or -1 otherwise or on
error.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>
<refsect2>
<title><anchor id="g-creat" role="function" condition="since:2.8"/>g_creat ()</title>
<indexterm role="2.8"><primary>g_creat</primary></indexterm><programlisting><link linkend="int">int</link>                 g_creat                             (const <link linkend="gchar">gchar</link> *filename,
                                                         <link linkend="int">int</link> mode);</programlisting>
<para>
A wrapper for the POSIX <link linkend="creat"><function>creat()</function></link> function. The <link linkend="creat"><function>creat()</function></link> function is
used to convert a pathname into a file descriptor, creating a file
if necessary. Note that on POSIX systems file descriptors are
implemented by the operating system. On Windows, it's the C library
that implements <link linkend="creat"><function>creat()</function></link> and file descriptors. The actual Windows
API for opening files is something different.
</para>
<para>
See the C library manual for more details about <link linkend="creat"><function>creat()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>filename</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>mode</parameter>&nbsp;:</term>
<listitem><simpara> as in <link linkend="creat"><function>creat()</function></link>
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> a new file descriptor, or -1 if an error occurred. The
return value can be used exactly like the return value from <link linkend="creat"><function>creat()</function></link>.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>
<refsect2>
<title><anchor id="g-chdir" role="function" condition="since:2.8"/>g_chdir ()</title>
<indexterm role="2.8"><primary>g_chdir</primary></indexterm><programlisting><link linkend="int">int</link>                 g_chdir                             (const <link linkend="gchar">gchar</link> *path);</programlisting>
<para>
A wrapper for the POSIX <link linkend="chdir"><function>chdir()</function></link> function. The function changes the
current directory of the process to <parameter>path</parameter>.
</para>
<para>
See your C library manual for more details about <link linkend="chdir"><function>chdir()</function></link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>path</parameter>&nbsp;:</term>
<listitem><simpara> a pathname in the GLib file name encoding (UTF-8 on Windows)
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis>&nbsp;:</term><listitem><simpara> 0 on success, -1 if an error occurred.

</simpara></listitem></varlistentry>
</variablelist><para role="since">Since  2.8
</para></refsect2>

</refsect1>





<refsect1><refsect2 /><refsect2 /></refsect1>
</refentry>
