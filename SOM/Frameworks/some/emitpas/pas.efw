:copyrightS

  SOM Compiler Pascal Interface Emitter (C) Yuri Prokushev
                                        (C) Andrey Vasilkin

:prologS
Unit <classSourceFileStem>Int;
(**************************************************************************
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using template emitter:
 *      SOM Emitter emitpas: 1.0, <timeStamp>
 **************************************************************************)

{$IFDEF FPC}
  {$MODE OBJFPC}
{$ENDIF}

{$IFDEF VIRTUALPASCAL}
  {&Cdecl+}
{$ENDIF}

Interface
:baseIncludesPrologS
Uses
  SOM, SOMMI
:baseIncludesS
  , <baseSourceFileStem>Int
:baseIncludesEpilogS
  ;

:pasTypedefsPrologS
type
  TReal<className>: TReal<directBase>;
  PReal<className>: ^TReal<className>;

:pasForwardClassS
  T<defDeclName> = class;

:pasTypedefS
?  <-- pasComment>
  T<defDeclName> = <typedefPasBaseType>;
:pasPTypedefS
?  <-- pasComment>
  P<defDeclName> = <typedefPasBaseType>;
:pasPtrToRecTypedefS
  P<defDeclName> = ^T<defDeclName>;
:pasTypedefEpilogS

:pasStructS
?  <-- pasComment>
  T<defDeclName> = record
:pasStructMemberS
    <structFieldName>: <typedefPasBaseType>;
:pasStructEpilogS
  end;

:pasUnionS
?  <-- pasComment>
  T<defDeclName> = record
    _d: <switchType>;
    case Longint of
:pasUnionMemberS
      <unionMemberLabel>: (<unionMemberName>: <unionMemberType>);
:pasUnionEpilogS
  end; // union

:pasSequenceS
  T<defDeclName> = record
    _maximum: Tlong;
    _length: Tlong;
    _buffer: array [0..<sequenceMax>] of <sequenceType>;
  end;

:pasEnumS
?<-- pasComment>
  T<defDeclName> = Tlong;
const
:pasEnumMemberS
  <enumName>            = <enumValue>;
:pasEnumPrologS

:pasConstantsPrologS

const
:constantS
?<-- constantComment>
  <constantName> = <pasConstantValueEvaluated>; // <pasConstType>
:classDataPrologS

  P<className>ClassData = ^T<className>ClassData;
  T<className>ClassData = record
    classObject: TRealSOMClass;
:classDataS
    <dataName>: Pointer;
:classDataEpilogS
  end; // static class data
:classS

?<-- classComment>
  {$DEFINE direct_parent_is_<directBase>}
  P<className> = ^T<className>;
  T<className> = class(T<directBase>)
  private
    somSelf: TRealSOMObject;
  public
    constructor Create;
    destructor Destroy;
:methodsS
?    <-- methodComment>
    <pasMethodFunc> <methodName><pasMethodHdrParamList; ...><pasMethodType>; virtual;
:overrideMethodsS
?    <-- methodComment>
    <pasMethodFunc> <methodName><pasMethodHdrParamList; ...><pasMethodType>; override;
:inheritedMethodsS
?    <-- methodComment>
    <pasMethodFunc> <methodName><pasMethodHdrParamList; ...><pasMethodType>; //inherited;
:pasAttributeRWS
?    <-- attributeComment>
    property <pasAttributeName>: <pasAttributeType> read _get_<pasAttributeName> write _set_<pasAttributeName>;
:pasAttributeROS
?    <-- attributeComment>
    property <pasAttributeName>: <pasAttributeType> read _get_<pasAttributeName>;
:attributeEpilogS
  end; // class T<className>

var
  <className>ClassDataPtr: ^T<className>ClassData;

const
  <className>_MajorVersion = <classMajorVersion>;
  <className>_MinorVersion = <classMinorVersion>;

:releaseS
Section: releaseS

  classReleaseOrder = "<classReleaseOrder, ...>"

:passthruS
Section: passthruS

  passthruName = "<passthruName>"
  passthruComment = "<-- passthruComment>"
  passthruLineNumber = "<passthruLineNumber>"
  passthruMods = "<passthruMods, ...>"
  passthruLanguage = "<passthruLanguage>"
  passthruTarget = "<passthruTarget>"
  passthruBody = "<passthruBody>"

:interfaceS
Section: interfaceS

  className = "<className>"
  classIDLScopedName = "<classIDLScopedName>"
  classCScopedName = "<classCScopedName>"
  classComment = "<-- classComment>"
  classInclude = "<classInclude>"
  classLineNumber = "<classLineNumber>"
  classMods = "<classMods, ...>"
  classMajorVersion = "<classMajorVersion>"
  classMinorVersion = "<classMinorVersion>"
  classReleaseOrder = "<classReleaseOrder, ...>"
  classSourceFile = "<classSourceFile>"
  classSourceFileStem = "<classSourceFileStem>"

:interfaceEpilogS
Section: interfaceEpilogS

:modulePrologS
Section: modulePrologS

:moduleS
Section: moduleS

  moduleName = "<moduleName>"
  moduleIDLScopedName = "<moduleIDLScopedName>"
  moduleCScopedName = "<moduleCScopedName>"
  moduleComment = "<-- moduleComment>"
  moduleLineNumber = "<moduleLineNumber>"
  moduleMods = "<moduleMods, ...>"

:pasImplementationPrologS

implementation

uses Os2Def, Os2Base, VPUtils;

procedure <className>MethodDebug(S: String; M: String);
begin
//  Writeln(S, ':', M);
end;

:pasMethodImplementationS
?  <-- methodComment>
<pasMethodFunc> T<className>.<methodName><pasMethodHdrParamList; ...><pasMethodType>;
type
  MT = <pasMethodFunc>(somSelf: TRealSOMObject<;pasMethodParamList; ...>)<pasMethodType>; {$IFNDEF VIRTUALPASCAL}cdecl;{$ENDIF}
var
  Method:MT;
begin
  <className>MethodDebug('<className>','<methodName>');
  @Method := somResolveByName(somSelf, '<methodName>'{<className>ClassDataPtr^.<methodName>});
  <pasMethodResult>Method(<pasMethodFullParamNameList, ...>);
end;

:basePrologS

constructor T<className>.Create;
type
  MT = function(somSelf: PReal<className>; ID: TsomId; major, minor: Longint): TReal<className>; {$IFNDEF VIRTUALPASCAL}cdecl;{$ENDIF}
  MT_somGetname = function(somSelf:TRealSOMClass): Tstring;
  MT_somNew = function(somSelf:TRealSOMClass): TRealSOMObject;
var
  somFindClass: MT;
  somNew: MT_somNew;
  somGetname: MT_somGetname;
const
  baseCount = <baseCount>;
var
  cm: TRealSOMClassMgr;
  classId: TsomId;
  myClass: TRealSOMClass;
const
  ModuleName   : PChar = 'SOM.DLL'; // Name of module
var
  LoadError    : Array[0..255] of Char; // Area for Load failure information
  ModuleHandle : hModule; // Module handle
  ModuleType   : ULong;   // Module type
  rc           : ApiRet;  // Return code
  SOMClassMgrClassDataPtr: ^TSOMClassMgrClassDataStructure; // This is declared in SOM.PAS
  SOMClassClassDataPtr:  ^TSOMClassClassDataStructure; // This is declared in SOM.PAS
begin
  <className>MethodDebug('<className>','Create');

//  inherited Create;

  // Query address of ClassData variable
  rc := DosLoadModule(
      LoadError,               // Failure information buffer
      sizeof(LoadError),       // Size of buffer
      ModuleName,              // Module to load
      ModuleHandle);          // Module handle returned

    rc := DosQueryProcAddr(
      ModuleHandle,        // Handle to module
      6,                   // No ProcName specified
      nil,                 // ProcName (not specified)
      Pointer(SOMClassMgrClassDataPtr));         // Address returned

    rc := DosQueryProcAddr(
      ModuleHandle,        // Handle to module
      3,                   // No ProcName specified
      nil,                 // ProcName (not specified)
      Pointer(SOMClassClassDataPtr));         // Address returned


    rc := DosFreeModule(ModuleHandle);


  // Query address of ClassData variable
  rc := DosLoadModule(
      LoadError,               // Failure information buffer
      sizeof(LoadError),       // Size of buffer
      <pasDllName>,              // Module to load
      ModuleHandle);          // Module handle returned

    rc := DosQueryProcAddr(
      ModuleHandle,        // Handle to module
      0,//14,                   // No ProcName specified
      '<className>ClassData',                 // ProcName (not specified)
      Pointer(<className>ClassDataPtr));         // Address returned

    rc := DosFreeModule(ModuleHandle);

  // Initialize SOM Run-time
  cm:=somEnvironmentNew;

  // Search for SOMObject class ID
  classId:=somIdFromString('<className>');

  // Resolve somFindClass method of Class Manager
  @somFindClass:=somResolve(cm, SOMClassMgrClassDataPtr^.somFindClass);

  // Search class and create class object
  myClass:=somFindClass(cm, classId, <className>_MajorVersion, <className>_MinorVersion);
//  SOMFree(classId);

  // Create object of class
  if (myClass=nil) then
  begin
    WriteLn('somFindClass could not find the selected class');
  end else begin
    @somGetname:=somResolve(myClass, SOMClassClassDataPtr^.somGetname);

    @somNew:=somResolve(myClass, SOMClassClassDataPtr^.somNew);
    somSelf:=somNew(myClass);
  end;

  // Call object constructor
//  somDefaultInit(nil);

  SetParentsCount(baseCount-1);
:baseS
  {$IFNDEF direct_parent_is_<baseName>}SetParent(T<baseName>);{$ENDIF}
:baseEpilogS
end; // constructor

destructor T<className>.Destroy;
begin
  // Call object destructor
  inherited Destroy;
end;

begin
  // Don't call SOM here. SOM runtime initialized after first SOM
  // object creation.
end.



:typedefPrologS
:typedefEpilogS
:attributePrologS
:methodsEpilogS
:metaS
:moduleEpilogS
:interfacePrologS
:unionPrologS
:passthruPrologS
:passthruEpilogS
:structPrologS
:typedefS
:structEpilogS
:enumEpilogS
:constantPrologS
:constantEpilogS
:unionPrologS
:unionEpilogS
